"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[892],{3182:function(e,n,i){i.d(n,{Z:function(){return a}});var t=i(5893),r=i(5675),o=i.n(r),s=i(6010);function a(e){var n=e.src,i=e.alt,r=e.width,a=e.height,l=e.caption,c=e.className;return(0,t.jsxs)("div",{className:"flex flex-col items-center ",children:[(0,t.jsx)("span",{className:(0,s.Z)(c||"","overflow-hidden rounded-xl"),children:(0,t.jsx)(o(),{src:n,alt:i,width:r,height:a,placeholder:"blur",blurDataURL:n})}),l&&(0,t.jsx)("p",{className:"mt-2 mb-0 text-sm font-light text-gray-600 dark:text-gray-400",children:l})]})}},8892:function(e,n,i){i.r(n);var t=i(5893),r=i(1151),o=i(3182);function s(e){var n=Object.assign({hr:"hr",h2:"h2",p:"p",blockquote:"blockquote",strong:"strong",pre:"pre",code:"code",ol:"ol",li:"li",ul:"ul",a:"a"},(0,r.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{children:'slug: "dynamic-programming-for-dummies"\ntitle: "Dynamic Programming for Dummies"\ndescription: "Careful brute force"\npublishedAt: "2021-10-08"'}),"\n","\n",(0,t.jsx)(n.h2,{children:"Intro"}),"\n",(0,t.jsx)(n.p,{children:"What is dynamic programming?"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This might sound rather vague and a bit intimidating. My definition?"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"careful brute force"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In class we are used to learning about all sorts of algorithms like binary search where memorization of the algorithm can be favored in exchange of understanding the underlying concept. Often times, I hear my friends growl whenever we bump into a DP/recursion problem while doing interview prep. I hope that with this article I can shed some light behind dynamic programming and teach you how you can intuitively deconstruct a problem and solve it!"}),"\n",(0,t.jsx)(n.h2,{children:"Fibonacci Sequence"}),"\n",(0,t.jsx)(n.p,{children:"There\u2019s no better way to explain DP than using the Fibonacci Sequence. To give you a quick refresher, the sequence is constructed such that each number is the sum of the two preceding ones."}),"\n",(0,t.jsx)(o.Z,{src:"/images/journal/dynamic-programming-for-dummies/1.png",height:"272px",width:"640px",className:"img-invert"}),"\n",(0,t.jsx)(n.h2,{children:"Recursive Implementation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The first step to DP is to figure out sub-problems."})," We are going to take a top-down approach where we break the initial problem into smaller and smaller subproblems that become effectively easier to solve. In the case of Fibonacci, we will start with the number we want to find and trickle our way downwards to the base case, which is the first two elements of the sequence, 1 & 1."]}),"\n",(0,t.jsx)(n.p,{children:"I\u2019ve took the liberty and implemented the aforementioned solution in python."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def fib(n):\n  if n <= 2:\n    return 1\n  else:\n    return fib(n - 1) + fib(n - 2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"It looks fairly straightforward, right?"}),"\n",(0,t.jsx)(n.p,{children:"Before we move any further, we need to take a step back and analyze the time complexity or as it is called in this case, the recurrence. This can be rather tricky to calculate, therefore approximating the result is perfectly fine."}),"\n",(0,t.jsx)(o.Z,{src:"/images/journal/dynamic-programming-for-dummies/2.png",height:"413px",width:"640px",className:"img-invert"}),"\n",(0,t.jsxs)(n.p,{children:["Hmm \ud83e\udd14, looks like the ",(0,t.jsx)(n.code,{children:"fib"})," function has ",(0,t.jsx)(n.strong,{children:"exponential time"}),". Let me explain! The problem is that we end up calculating a bunch of the same values multiple times."]}),"\n",(0,t.jsx)(o.Z,{src:"/images/journal/dynamic-programming-for-dummies/3.png",height:"447px",width:"640px",className:"img-invert"}),"\n",(0,t.jsx)(n.h2,{children:"Memoized Recursive Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["The beauty of DP is that it can shrink down the exponential time complexity of a brute force algorithm to polynomial (\u2248 linear) time. ",(0,t.jsx)(n.strong,{children:"The second step of DP is to memoize and reuse those subproblems."})]}),"\n",(0,t.jsxs)(n.p,{children:["Going back to our ",(0,t.jsx)(n.code,{children:"fib"})," implementation this is fairly easy to implement by using a dictionary that will keep track of solutions that have been already solved."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"memo = {}\ndef fib(n):\n  if n in memo:\n    return memo[n]\n  if n <= 2:\n    f = 1\n  else:\n    f = fib(n - 1) + fib(n - 2)\n  memo[n] = f\n  return f\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, calculating the time complexity comes down to multiplying the number of subproblems by the amount of time per subproblem (no need to count memoized solutions). This quick optimization reduced the complexity from exponential time to linear time, ",(0,t.jsx)(n.code,{children:"O(n)"}),". We have ",(0,t.jsx)(n.code,{children:"n"})," subproblems (n fibonacci numbers that we need to calculate and for each one of them it takes ",(0,t.jsx)(n.code,{children:"O(1)"})," to compute."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"time complexity = subproblems * (time complexity / subproblem)"}),"\n"]}),"\n",(0,t.jsx)(o.Z,{src:"/images/journal/dynamic-programming-for-dummies/4.png",height:"495px",width:"640px",className:"img-invert"}),"\n",(0,t.jsx)(n.h2,{children:"Iterative Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Some people prefer to take an iterative approach instead of recursion. Everyone has their own style of solving problems and writing code, so I also wanted to briefly mention the iterative solution for DP. In this case, you would want to take a bottom-up approach and create a DP table that will memoize the previous solutions."}),"\n",(0,t.jsxs)(n.p,{children:["In this implementation of ",(0,t.jsx)(n.code,{children:"fib"})," I\u2019m only memoizing the last 2 numbers of the sequence since that is all we need."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def fib(n):\n  a, b = 1, 1\n\n  for i in range(n):\n    a, b = b, a + b\n\n  return a\n"})}),"\n",(0,t.jsx)(n.h2,{children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"To sum up DP in 5 \u201ceasy steps\u201d here\u2019s the battle tested approach that will work for any problem:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"define and split into subproblems"}),"\n",(0,t.jsx)(n.li,{children:"guess part of the solution (this will only become more clear with time)"}),"\n",(0,t.jsx)(n.li,{children:"relate subproblems"}),"\n",(0,t.jsx)(n.li,{children:"recurse and memoization (reuse subproblems)"}),"\n",(0,t.jsx)(n.li,{children:"solve original problem"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"I hope that from now on you will approach DP problems with joy and excitement!"}),"\n",(0,t.jsx)(n.h2,{children:"Citations"}),"\n",(0,t.jsx)(n.p,{children:"This article wouldn\u2019t have been possible without the following materials:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dynamic_programming",children:"Wikipedia \u2014 Dynamic Programming"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.youtube.com/watch?v=OQ5jsbhAv_M",children:"Dynamic Programming I: Fibonacci, Shortest Paths"})}),"\n"]})]})}n.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,r.a)(),e.components),i=n.wrapper;return i?(0,t.jsx)(i,Object.assign({},e,{children:(0,t.jsx)(s,e)})):s(e)}}}]);
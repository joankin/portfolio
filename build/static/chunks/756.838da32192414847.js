"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[756],{3182:function(e,n,i){i.d(n,{Z:function(){return r}});var t=i(5893),a=i(5675),s=i.n(a),o=i(6010);function r(e){var n=e.src,i=e.alt,a=e.width,r=e.height,c=e.caption,l=e.className;return(0,t.jsxs)("div",{className:"flex flex-col items-center ",children:[(0,t.jsx)("span",{className:(0,o.Z)(l||"","overflow-hidden rounded-xl"),children:(0,t.jsx)(s(),{src:n,alt:i,width:a,height:r,placeholder:"blur",blurDataURL:n})}),c&&(0,t.jsx)("p",{className:"mt-2 mb-0 text-sm font-light text-gray-600 dark:text-gray-400",children:c})]})}},6756:function(e,n,i){i.r(n);var t=i(5893),a=i(1151),s=i(3182);function o(e){var n=Object.assign({hr:"hr",h2:"h2",p:"p",code:"code",pre:"pre",ol:"ol",li:"li"},(0,a.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{children:'slug: "custom-paging-ui-in-swiftui"\ntitle: "Custom Paging UI in SwiftUI"\ndescription: "Create animated index views with the new PageTabViewStyle"\npublishedAt: "2020-08-03"'}),"\n","\n",(0,t.jsx)(s.Z,{src:"/images/journal/custom-paging-ui-in-swiftui/1.jpeg",alt:"",width:"700",height:"514"}),"\n",(0,t.jsxs)(n.p,{children:["SwiftUI 2 introduced a new ",(0,t.jsx)(n.code,{children:"TabView"})," style called ",(0,t.jsx)(n.code,{children:"PageTabViewStyle"})," that enables developers to easily create horizontal Pagers (aka Paging) with dots at the bottom to show users where they are. This is the equivalent of ",(0,t.jsx)(n.code,{children:"UIPageViewController"})," from UIKit."]}),"\n",(0,t.jsxs)(n.p,{children:["Today, we will cover how to use the new style for ",(0,t.jsx)(n.code,{children:"TabView"})," and how to create a custom ",(0,t.jsx)(n.code,{children:"IndexView"})," component."]}),"\n",(0,t.jsx)(s.Z,{src:"/images/journal/custom-paging-ui-in-swiftui/2.gif",alt:"Collection of animations",caption:"Collection of animations",width:"800",height:"364"}),"\n",(0,t.jsx)(n.h2,{children:"Getting Started"}),"\n",(0,t.jsxs)(n.p,{children:["Using the new API is as simple as setting the new ",(0,t.jsx)(n.code,{children:"PageTabViewStyle"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-swift",children:"struct ContentView: View {\n\n  // MARK: - Private Properties\n\n  @State private var currentIndex = 0\n  private let colors: [Color] = [.red, .blue, .green, .yellow]\n\n  // MARK: - Body\n\n  var body: some View {\n    TabView(selection: $currentIndex) {\n      ForEach(0..<colors.count, id: \\.self) { index in\n        colors[index]\n          .tag(index)\n      }\n    }\n    .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, I have an array of colors \u2014 with each color being a page \u2014 and I am also tagging every ",(0,t.jsx)(n.code,{children:"Color"})," view with its desired index. The ",(0,t.jsx)(n.code,{children:"TabView"})," initializer has a ",(0,t.jsx)(n.code,{children:"selection"})," binding that represents the current page."]}),"\n",(0,t.jsx)(s.Z,{src:"/images/journal/custom-paging-ui-in-swiftui/3.png",alt:"Collection of paging animations",caption:"Collection of animations",width:"700",height:"356"}),"\n",(0,t.jsx)(n.p,{children:"A couple of things to keep in mind:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The paging dots are white and translucent. Therefore, if your background is also white, you won\u2019t see them (tested on iOS/Xcode Beta 3)."}),"\n",(0,t.jsxs)(n.li,{children:["The contents of the ",(0,t.jsx)(n.code,{children:"TabView"})," cannot be drawn over the safe area insets (Tested on iOS/Xcode Beta 3)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{children:"Creating a Custom IndexView"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we have the basics covered, we can quickly create any custom component to represent the current page and update it accordingly with our ",(0,t.jsx)(n.code,{children:"currentIndex"})," state property."]}),"\n",(0,t.jsx)(n.p,{children:"We are going to take a stab at making a more dynamic version of the system dots. This index component will present at most three dots and animate the insertion/removal as you swipe through the pages."}),"\n",(0,t.jsx)(s.Z,{src:"/images/journal/custom-paging-ui-in-swiftui/4.png",width:"350",height:"174"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-swift",children:"struct Fancy3DotsIndexView: View {\n\n  // MARK: - Public Properties\n\n  let numberOfPages: Int\n  let currentIndex: Int\n\n\n  // MARK: - Drawing Constants\n\n  private let circleSize: CGFloat = 16\n  private let circleSpacing: CGFloat = 12\n\n  private let primaryColor = Color.white\n  private let secondaryColor = Color.white.opacity(0.6)\n\n  private let smallScale: CGFloat = 0.6\n\n\n  // MARK: - Body\n\n  var body: some View {\n    HStack(spacing: circleSpacing) {\n      ForEach(0..<numberOfPages) { index in // 1\n        if shouldShowIndex(index) {\n          Circle()\n            .fill(currentIndex == index ? primaryColor : secondaryColor) // 2\n            .scaleEffect(currentIndex == index ? 1 : smallScale)\n\n            .frame(width: circleSize, height: circleSize)\n\n            .transition(AnyTransition.opacity.combined(with: .scale)) // 3\n\n            .id(index) // 4\n        }\n      }\n    }\n  }\n\n\n  // MARK: - Private Methods\n\n  func shouldShowIndex(_ index: Int) -> Bool {\n    ((currentIndex - 1)...(currentIndex + 1)).contains(index)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"That\u2019s quite a bit of code, so let\u2019s go through it step by step:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ForEach"})," and ",(0,t.jsx)(n.code,{children:"shouldShowIndex()"})," \u2014 Display only three dots or less (for the current page and its adjacent pages)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".fill()"})," and ",(0,t.jsx)(n.code,{children:".scale()"})," \u2014 Apply different styling to showcase which ",(0,t.jsx)(n.code,{children:"Circle"})," is focused."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".transition()"})," \u2014 Animate the insertion and removal of each ",(0,t.jsx)(n.code,{children:"Circle"})," with opacity and scale."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".id(index)"})," \u2014 Create unique ",(0,t.jsx)(n.code,{children:"Circle"})," instances for each index."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{children:"Final Step"}),"\n",(0,t.jsxs)(n.p,{children:["Now we just need to update ",(0,t.jsx)(n.code,{children:"ContentView"})," to make use of the new ",(0,t.jsx)(n.code,{children:"Fancy3DotsIndexView"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Add an implicit animation for every change that happens to the ",(0,t.jsx)(n.code,{children:"currentIndex"})," binding."]}),"\n",(0,t.jsxs)(n.li,{children:["Overlay the new ",(0,t.jsx)(n.code,{children:"IndexView"})," component and plug in the necessary properties."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-swift",children:"struct ContentView: View {\n\n  // ...\n\n  var body: some View {\n    TabView(selection: $currentIndex.animation()) { // 1\n      ForEach(0..<colors.count, id: \\.self) { index in\n        colors[index]\n          .tag(index)\n      }\n    }\n    .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))\n    .overlay(Fancy3DotsIndexView(numberOfPages: colors.count, currentIndex: currentIndex)) // 2\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Voil\xe0!"}),"\n",(0,t.jsx)(s.Z,{src:"/images/journal/custom-paging-ui-in-swiftui/5.gif",alt:"Final product animation",caption:"Final product",width:"800",height:"206"}),"\n",(0,t.jsx)(n.h2,{children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["Making animations in SwiftUI was already insanely easy, and now with the new ",(0,t.jsx)(n.code,{children:"TabView"})," style, you can create any kind of index view! Stay tuned for my upcoming articles!"]}),"\n",(0,t.jsx)(n.p,{children:"If you are feeling brave enough, I encourage you to try to make your own animations!"})]})}n.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,a.a)(),e.components),i=n.wrapper;return i?(0,t.jsx)(i,Object.assign({},e,{children:(0,t.jsx)(o,e)})):o(e)}}}]);